#include "/EGP/ScreenPass/pre.ush"

//Hint to Materials which shader we're running in.
#define GOL_PASS_SIMULATE 1

//Stage 1:
static float MaterialDeltaSeconds;
static float2 MaterialNeighborStates[9];
//Stage 2:
static float MaterialNewDiscreteValue;
static float MaterialDiscreteSeverityT;

#include "/EGP/ScreenPass/post.ush"


float DeltaSeconds;
#define SimStateTex PostProcessInput_0_Texture
RWTexture2D<float2> NextSimStateTex;

[numthreads(SIM_GROUP_SIZE_X, SIM_GROUP_SIZE_Y, SIM_GROUP_SIZE_Z)]
void Main(uint3 threadIdx : SV_DispatchThreadID)
{
	//We get annoying shader warnings from re-use of loop variables, so pre-declare them here.
	int i, x, y;
	
	uint2 resolution;
	SimStateTex.GetDimensions(resolution.x, resolution.y);

	uint2 pixel = threadIdx.xy;
	float2 uv = (float2(pixel) + 0.5) / float2(resolution);
	if (any(pixel >= resolution))
		return;
	
	//Sample the neighboring cell states.
	float2 prevStates[9];
	const int ourIdx = 4;
	for (x = -1; x <= 1; ++x)
		for (y = -1; y <= 1; ++y)
		{
			int2 globalIdx = pixel + int2(x, y);
			int localIdx = (x + 1) + ((y + 1) * 3);
			prevStates[localIdx] = any(bool4(globalIdx < 0, globalIdx >= resolution)) ?
				float2(0, 0) :
				SimStateTex[globalIdx].xy;
		}

	//Set up the Material code.
	FPixelMaterialInputs matInputs;
	FMaterialPixelParameters matParams;
	ScreenPassSetupCS(pixel, uv,
					  //Fake "world pos" and "fragment depth":
					  float3((uv * 2) - 1, 0), 0.0,
					  matInputs, matParams);

	//Run stage 1 of the Material graph's logic.
	MaterialDeltaSeconds = DeltaSeconds;
	for (i = 0; i < 9; ++i)
		MaterialNeighborStates[i] = prevStates[i];
	float thresholdTooFew =
		#if HAVE_GoL_Outputs_Simulate_Pt1_0
			GoL_Outputs_Simulate_Pt1_0(matParams)
		#else
			2.0
		#endif
	;
	float thresholdResurrect =
		#if HAVE_GoL_Outputs_Simulate_Pt1_1
			GoL_Outputs_Simulate_Pt1_1(matParams)
		#else
			2.5
		#endif
	;
	float thresholdTooMany =
		#if HAVE_GoL_Outputs_Simulate_Pt1_2
			GoL_Outputs_Simulate_Pt1_2(matParams)
		#else
			3
		#endif
	;
	//Count the number of living neighbors surrounding us.
	float neighborStrength = 0;
	const float maxStrength = 8.0;
	for (i = 0; i < 9; ++i)
		if (i != ourIdx)
			neighborStrength += prevStates[i].x;
	//Apply the usual Game of Life rules to our cell, dying/living/resurrecting
	//    based on how many living neighbors we have.
	//Also calculate a "severity" estimating the strength of the pull towards that value.
	float targetValue, severityT;
	if (neighborStrength < thresholdTooFew)
	{
		//Die off, from underpopulation.
		targetValue = 0;
		severityT = 1.0 - (neighborStrength / thresholdTooFew);
	}
	else if (neighborStrength < thresholdResurrect)
	{
		//Maintain current living status, from a normal population.
		targetValue = prevStates[ourIdx].x;
		severityT = 1.0;
	}
	else if (neighborStrength <= thresholdTooMany)
	{
		//Come alive, from an ideal population.
		targetValue = 1;
		severityT = (neighborStrength - thresholdResurrect) / max(0.0001, thresholdTooMany - thresholdResurrect);
	}
	else
	{
		//Die, from overpopulation.
		targetValue = 0;
		severityT = (neighborStrength - thresholdTooMany) / max(0.0001, maxStrength - thresholdTooMany);
	}

	//Run stage 2 of the Material graph's logic.
	MaterialNewDiscreteValue = targetValue;
	MaterialDiscreteSeverityT = severityT;
	float smoothValue =
		#if HAVE_GoL_Outputs_Simulate_Pt2_0
			GoL_Outputs_Simulate_Pt2_0(matParams)
		#else
			targetValue
		#endif
	;

	NextSimStateTex[pixel] = float2(targetValue, smoothValue);
}